

    public void insertionSort(){
        int in, out;
        for(out=1; out < nElems; out++){          // out - разделительный маркер
            long temp = a[out];                 // —копировать помеченный элемент
            in = out;                           // Ќачать перемещени€ с out
            while(in > 0 && a[in-1] >= temp){     // ѕока не найден меньший элемент
                a[in] = a[in-1];                // —двинуть элемент вправо
                --in;                           // ѕерейти на одну позицию влево
            }
            a[in] = temp;                       // ¬ставить помеченный элемент
        }
    }



    ¬о внешнем цикле for счетчик начинает с позиции 1 и двигаетс€ вправо. ќн отмечает крайний левый неотсортированный элемент.
    ¬о внутреннем цикле while счетчик in начинает с позиции out и двигаетс€ влево Ч либо пока temp не станет меньше элемента
    массива, либо когда дальнейшее смещение станет невозможным. ѕри каждом проходе по циклу while следующий отсортированный
    элемент сдвигаетс€ на одну позицию вправо.


    ≈сли данные упор€дочены, то условие цикла while никогда не бывает истинным; следовательно, оно вырождаетс€ в простую команду
    во внешним цикле, выполн€емую N Ц 1 раз. ¬ этом случае алгоритм выполн€етс€ за врем€ O(N ). ≈сли данные почти отсортированы,
    то сортировка методом вставки выполн€етс€ почти за врем€ O(N ), а следовательно, €вл€етс€ простым и эффективным способом
    упор€дочени€ файлов данных с небольшими отклонени€ми в пор€дке сортировки. Ќо если данные изначально отсортированы в обратном
    пор€дке, алгоритму придетс€ выполнить все возможные сравнени€ и перемещени€, и тогда вставка методом сортировки выполн€етс€
    не быстрее пузырьковой сортировки

    —ортировка методом вставки выполн€етс€ за врем€ O(N^2)